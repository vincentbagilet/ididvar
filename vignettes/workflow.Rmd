---
title: "Quick workflow"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Quick workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(ididvar)
library(dplyr)
library(ggplot2)
library(tigris)
```

This vignette quickly presents a typical workflow for analysis, using a very basic example. It also provides an overview of most the functions available in the package.

A more thorough example, with an actual analysis and interpretation of the results, is available on the research project website. 

# Overview of a typical workglow

The workflow to make a plot from scratch is straightforward: 

1. Add a `weight` variable to the data set. Optionally, we can also add a `contrib` dummy. For that we need to determine the contribution threshold. Here I use the `idid_contrib_threshold` to find a weight threshold below which removing observations does not change the point estimate or the standard error of the estimate of interest by more than a given proportion.
1. Compute the weights at a group level of interest (here state level) by summing weights of observations in this group.
1. Visualize the 

# Compute weights

Let's assume we have already ran the regression of interest. 

```{r reg_ex, message=FALSE}
data_ex <- state.x77 |>
  as_tibble() |>
  mutate(
    state = rownames(state.x77),
    pop_quartiles = cut_interval(Population, 4, labels = FALSE),
    murder_quartiles = cut_interval(Murder, 4, labels = FALSE),
    income_quartiles = cut_interval(Income, 4, labels = FALSE)
  ) 

reg_ex <-lm(data = data_ex,
            formula = Illiteracy ~  Income + Population + `Life Exp` + Frost)
```

We can **add the weights to the data**.

```{r data_ex_weights}
data_ex_weights <- data_ex |> 
  mutate(weight = idid_weights(reg_ex, "Income"))
```

# Visualize the weights

We can then *visualize the weights*. 

## Weights distribution

We can first plot their distribution using the `idid_viz_cumul` function.

```{r idid_viz_cumul}
idid_viz_cumul(data_ex_weights$weight)
```

That allows us to analyse the extend to which the weights are evenly distributed. A very unequal distribution should hint that some observations contribute much more to identification and that some observations may not contribute much.

We may then want to explore the distribution of weights along several variables. Depending on the shape of the data, there might be some obvious way to analyse it: if the data is an individual-time panel, one may want to group it by individual and time. That can be done with, by providing these two dimensions as the `var_x` and `var_y` arguments.

When the data has a geographical dimension, one may want to plot a map of the weights. The function `idid_viz_weights_map` allows to do easily do that by only providing a shape file in a `sf` format along with the join variable name.

```{r idid_viz_weights_map}
states_sf <- tigris::states(
    cb = TRUE, resolution = "20m", year = 2024, progress_bar = FALSE) |>
  tigris::shift_geometry() |> 
  rename(state = NAME)

idid_viz_weights_map(reg_ex, "Income", states_sf, "state")
```

In addition--or instead--, it is often interesting to analyse whether some groups have larger weights, *ie* contribute more, than others. One may have a priori ideas regarding which variables to group by. In cases when this might be less clear, one can use `idid_grouping_var` to identify variables for which groups created by and pass for instance all the variables in the dataset. 

```{r}
idid_grouping_var(reg_ex, "Income", 
                  c("income_quartiles", "pop_quartiles", "murder_quartiles"))
```


```{r}
idid_viz_weights(reg_ex, "Income", pop_quartiles)
```






```{r}
data_partial <- 
  tibble(
    illiteracy_per = idid_partial_out(reg_ex, "Illiteracy"),
    income_per = idid_partial_out(reg_ex, "Income"),
    weight = (income_per - mean(income_per))^2
  ) |> 
  mutate(
    weight = weight/sum(weight),
    logweight = log10(weight * length(weight))
  )

graph <- data_partial |>
  ggplot2::ggplot(aes(x = income_per, y = illiteracy_per, color = logweight)) +
  ggplot2::geom_point() +
  ggplot2::geom_smooth(
    method = "lm", 
    color = idid_colors_table[["base"]],
    fill = idid_colors_table[["base"]], 
    alpha = 0.1) +
  ididvar::theme_idid() +
  ididvar::scale_color_idid()

graph
```













